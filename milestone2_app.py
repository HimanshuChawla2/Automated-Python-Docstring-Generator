"""Module autogenerated docstring."""

import ast
import streamlit as st
import plotly.graph_objects as go
import pydocstyle
import tomllib
from pathlib import Path


def load_pyproject():
    """Loading project."""
    config_path = Path("pyproject.toml")
    if not config_path.exists():
        return {}
    try:
        with open(config_path, "rb") as f:
            return tomllib.load(f).get("tool", {}).get("docgen", {})
    except Exception:
        return {}


# ==========================================================================================
# 1. AST HELPERS
# ==========================================================================================


def attach_parents(tree):
    """Attach parent pointers to all AST nodes."""
    for node in ast.walk(tree):
        for child in ast.iter_child_nodes(node):
            child.parent = node


def extract_parameters(node):
    """Return safe parameter list for functions and methods."""
    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
        return [a.arg for a in node.args.args]
    return []  # Classes have no params


def map_nodes(tree):
    """Create mapping of classes and functions including docstring presence."""
    node_map = {"functions": [], "classes": []}

    for node in ast.walk(tree):

        # -------- Functions --------
        if isinstance(node, ast.FunctionDef) and not isinstance(getattr(node, "parent", None), ast.ClassDef):
            node_map["functions"].append(
                {
                    "node": node,
                    "name": node.name,
                    "params": extract_parameters(node),
                    "has_doc": ast.get_docstring(node) is not None,
                }
            )

        # -------- Classes --------
        if isinstance(node, ast.ClassDef):
            class_entry = {
                "node": node,
                "name": node.name,
                "params": [],  # <-- ADD THIS
                "has_doc": ast.get_docstring(node) is not None,
                "methods": [],
            }

            for item in node.body:
                if isinstance(item, ast.FunctionDef):
                    class_entry["methods"].append(
                        {
                            "node": item,
                            "name": item.name,
                            "params": extract_parameters(item),
                            "has_doc": ast.get_docstring(item) is not None,
                        }
                    )

            node_map["classes"].append(class_entry)

    return node_map


def add_module_docstring(code):
    """Insert a module-level docstring at the top if missing."""
    try:
        tree = ast.parse(code)
        if ast.get_docstring(tree) is not None:
            return code  # Already has module docstring
    except SyntaxError:
        return code

    module_doc = '"""Module description."""\n\n'

    # Insert at the very top
    return module_doc + code


# Pretty minimalist alert cards for violations
def render_violation(msg):
    """Auto-generated docstring."""
    is_warning = msg.code.startswith("D2")
    bg = "rgba(250, 204, 21, 0.12)" if is_warning else "rgba(239, 68, 68, 0.12)"
    border = "#facc15" if is_warning else "#ef4444"
    st.markdown(
        f"""
    <div style="
        padding: 12px 16px;
        margin: 8px 0;
        border-radius: 10px;
        border-left: 4px solid {border};
        background: {bg};
        color: #e5e7eb;
        font-size: 0.9rem;
        line-height: 1.4;
    ">
        <strong>{msg.filename}:{msg.line}</strong><br>
        {msg.code}: {msg.message}
    </div>
    """,
        unsafe_allow_html=True,
    )


# ==============================================================
#  EXTRA SECTION DETECTORS: Raises, Yields, Attributes
# ==============================================================


def detect_raises(node):
    """Return a list of exceptions raised inside a function."""
    raises = []
    for n in ast.walk(node):
        if isinstance(n, ast.Raise) and n.exc:
            if isinstance(n.exc, ast.Call):
                raises.append(n.exc.func.id)
            elif isinstance(n.exc, ast.Name):
                raises.append(n.exc.id)
    return raises


def detect_yields(node):
    """Return True if function contains yield statements."""
    for n in ast.walk(node):
        if isinstance(n, (ast.Yield, ast.YieldFrom)):
            return True
    return False


def detect_attributes(class_node):
    """Return assigned class attributes (class vars + self.x)."""
    attrs = []

    for n in class_node.body:

        # class variable assignments: x = 10
        if isinstance(n, ast.Assign):
            for t in n.targets:
                if isinstance(t, ast.Name):
                    attrs.append(t.id)

        # inside functions: self.x = ...
        if isinstance(n, ast.FunctionDef):
            for inner in ast.walk(n):
                if isinstance(inner, ast.Assign):
                    for t in inner.targets:
                        if isinstance(t, ast.Attribute) and isinstance(t.value, ast.Name) and t.value.id == "self":
                            attrs.append(t.attr)
    return list(set(attrs))  # unique attributes


# ==========================================================================================
# 2. DOCSTRING GENERATOR TEMPLATES
# ==========================================================================================


def generate_docstring_google(name, params):
    """Google style with summary on same line."""
    summary = name.capitalize() + "."

    param_lines = "\n".join([f"    {p}: Description." for p in params])

    return f'''"""{summary}

Args:
{param_lines if params else "    None"}
Returns:
    Description.
"""'''


def generate_docstring_numpy(name, params):
    """Numpy style with same-line summary."""
    summary = name.capitalize() + "."

    param_lines = "\n".join([f"{p} : type\n    Description." for p in params])

    return f'''"""{summary}

Parameters
----------
{param_lines if params else "None"}

Returns
-------
type
    Description.
"""'''


def generate_docstring_rest(name, params):
    """Rest style with same-line summary."""
    summary = name.capitalize() + "."

    param_lines = "\n".join([f":param {p}: Description." for p in params])

    return f'''"""{summary}

{param_lines if params else ""}

:returns: Description.
"""'''


def build_docstring(format_type, name, params):
    """Auto-generated docstring."""
    if format_type == "Google":
        return generate_docstring_google(name, params)
    if format_type == "NumPy":
        return generate_docstring_numpy(name, params)
    return generate_docstring_rest(name, params)


# ==========================================================================================
# 3. INSERTING DOCSTRINGS INTO RAW CODE
# ==========================================================================================


def insert_docstrings_into_code(code, node_map, format_type, mode):
    """Insert or rewrite docstrings safely with correct indentation."""
    lines = code.split("\n")
    new_lines = lines.copy()

    # Sort nodes bottom to top
    all_nodes = []
    for fn in node_map["functions"]:
        all_nodes.append(fn)
    for cls in node_map["classes"]:
        all_nodes.append(cls)
        for m in cls["methods"]:
            all_nodes.append(m)

    all_nodes = sorted(all_nodes, key=lambda x: x["node"].lineno, reverse=True)

    for item in all_nodes:
        node = item["node"]
        name = item["name"]
        params = item.get("params", [])
        has_doc = item["has_doc"]

        # Skip rewriting docstrings if mode is "missing"
        if mode == "missing" and has_doc:
            continue

        doc = build_docstring(format_type, name, params)

        # Determine indentation level
        def_line = lines[node.lineno - 1]
        indent = len(def_line) - len(def_line.lstrip(" "))

        # Build formatted docstring lines
        doc_lines = []
        doc_content = [line for line in doc.split("\n")]

        # Remove empty first/last lines
        while doc_content and doc_content[0].strip() == "":
            doc_content.pop(0)
        while doc_content and doc_content[-1].strip() == "":
            doc_content.pop()

        doc_lines = [" " * (indent + 4) + line for line in doc_content]

        # Insert docstring immediately after def line
        insertion_index = node.lineno

        # If function/class already has docstring, remove it first
        if has_doc:
            first_stmt = node.body[0]
            if isinstance(first_stmt, ast.Expr) and isinstance(first_stmt.value, ast.Str):
                start = first_stmt.lineno - 1
                end = first_stmt.end_lineno
                del new_lines[start:end]
                insertion_index = start

        # Insert docstring block
        for lines in reversed(doc_lines):
            new_lines.insert(insertion_index, lines)

    return "\n".join(new_lines)


# ==========================================================================================
# 4. PEP-257 CHECKING USING pydocstyle
# ==========================================================================================


def check_pep257(code):
    """Run pydocstyle on a temporary file and return violations."""
    import tempfile
    import os

    with tempfile.NamedTemporaryFile(delete=False, suffix=".py", mode="w", encoding="utf-8") as tmp:
        tmp.write(code)
        tmp_path = tmp.name

    # pydocstyle.check returns a generator of error objects
    violations = list(pydocstyle.check([tmp_path]))

    os.remove(tmp_path)
    return violations


# ==========================================================================================
# STREAMLIT UI
# ==========================================================================================

st.set_page_config(page_title="Python Docstring Analyzer", layout="wide")
st.title("Python Docstring Analyzer")


# Sidebar
st.sidebar.header("Upload Python File")
uploaded = st.sidebar.file_uploader("Choose .py file", type=["py"])

# Default UI values
ui_format = st.sidebar.radio("Docstring Format", ["Google", "NumPy", "reST"])
ui_mode = st.sidebar.radio("Docstring Mode", ["Only Missing", "Rewrite All"])

# Load project config (optional)
cfg = load_pyproject()

# Merge config with UI values
format_type = cfg.get("style", ui_format)

mode_from_cfg = cfg.get("rewrite", None)
if mode_from_cfg is True:
    mode_value = "rewrite"
elif mode_from_cfg is False:
    mode_value = "missing"
else:
    mode_value = "missing" if ui_mode == "Only Missing" else "rewrite"

process_btn = st.sidebar.button("Process File")
generate_btn = st.sidebar.button("Generate Docstrings")


# ==========================================================================================
# MAIN SCREEN
# ==========================================================================================

if uploaded:
    code = uploaded.read().decode("utf-8")

    st.subheader("Code Preview")
    st.code(code, language="python")

    # ====================================================
    # Coverage Summary (ONLY LIVE VERSION)
    # ====================================================
    tree = ast.parse(code)
    attach_parents(tree)
    node_map = map_nodes(tree)

    total_items = 0
    documented = 0

    for fn in node_map["functions"]:
        total_items += 1
        if fn["has_doc"]:
            documented += 1

    for cls in node_map["classes"]:
        total_items += 1
        if cls["has_doc"]:
            documented += 1

        for m in cls["methods"]:
            total_items += 1
            if m["has_doc"]:
                documented += 1

    coverage = round((documented / total_items) * 100, 2) if total_items else 0

    st.subheader("Documentation Coverage Summary (Live)")
    c1, c2, c3 = st.columns(3)

    c1.metric("Total Items", total_items)
    c2.metric("Documented", documented)
    c3.metric("Coverage", f"{coverage}%")

    # Pie Chart
    fig = go.Figure(
        data=[
            go.Pie(
                labels=["Documented", "Missing"],
                values=[documented, total_items - documented],
                hole=0.3,
            )
        ]
    )
    st.plotly_chart(fig, use_container_width=True)

    # ==============================================================
    # COUNT Raises / Yields / Attributes
    # ==============================================================

    raises_count = 0
    yields_count = 0
    attributes_count = 0

    for fn in node_map["functions"]:
        raises_count += len(detect_raises(fn["node"]))
        yields_count += 1 if detect_yields(fn["node"]) else 0

    for cls in node_map["classes"]:
        attributes_count += len(detect_attributes(cls["node"]))

    # ==============================================================
    #  PEP-257 VALIDATION (FINAL FIXED LOGIC)
    # ==============================================================

    if uploaded:
        st.subheader("PEP-257 Validation Results")

        # Run pydocstyle safely
        pep_report = list(check_pep257(code))

        # ---------------------------------------
        # OLD, CORRECT COUNTS RESTORED
        # ---------------------------------------
        warnings = sum(1 for r in pep_report if r.code.startswith("D2"))
        errors = sum(1 for r in pep_report if not r.code.startswith("D2"))

        # A file is compliant ONLY if it has zero warnings AND zero errors
        compliant = 1 if (warnings == 0 and errors == 0) else 0

        # ---------------------------------------
        # BAR CHART
        # ---------------------------------------
        bar = go.Figure()

        bar.add_bar(name="Compliant", x=["Compliant"], y=[compliant], marker_color="green")
        bar.add_bar(name="Warnings", x=["Warnings"], y=[warnings], marker_color="gold")
        bar.add_bar(name="Errors", x=["Errors"], y=[errors], marker_color="red")

        bar.update_layout(
            height=350,
            showlegend=False,
            margin=dict(l=20, r=20, t=20, b=20),
            yaxis_title="Count",
        )

        st.plotly_chart(bar, use_container_width=True)

        # ---------------------------------------
        # SUMMARY TEXT SECTION
        # ---------------------------------------
        st.markdown("### **Compliance Summary:**")

        st.markdown(
            f"""
        - üü¢ **Compliant:** {compliant}
        - ‚ö†Ô∏è **Warnings:** {warnings}
        - ‚ùå **Errors:** {errors}
        """
        )

        # ==============================================================
        # DISPLAY EXTRA SECTION COUNTS
        # ==============================================================

        st.markdown("**Additional Docstring Sections:**")

        st.markdown(
            f"""
        - üî∫ **Raises:** {raises_count}
        - üîÑ **Yields:** {yields_count}
        - üìå **Attributes:** {attributes_count}
        """
        )

        # ----------------------------
        #  DONUT CHART
        # ----------------------------
        donut = go.Figure(
            data=[
                go.Pie(
                    labels=["Compliant", "Warnings", "Errors"],
                    values=[compliant, warnings, errors],
                    hole=0.55,
                    marker=dict(colors=["#22c55e", "#facc15", "#ef4444"]),
                )
            ]
        )
        donut.update_layout(title_text="PEP-257 Compliance Distribution")
        st.plotly_chart(donut, use_container_width=True)

        # ---------------------------------------
        # LIST ERRORS/WARNINGS
        # ---------------------------------------

        if len(pep_report) == 0:
            st.success("üéâ All docstrings fully comply with PEP-257!")
        else:
            for msg in pep_report:
                is_warning = msg.code.startswith("D2")
                bg = "rgba(250, 204, 21, 0.12)" if is_warning else "rgba(239, 68, 68, 0.12)"
                border = "#facc15" if is_warning else "#ef4444"

                st.markdown(
                    f"""
                <div style="
                    padding: 12px 16px;
                    margin: 8px 0;
                    border-radius: 10px;
                    border-left: 4px solid {border};
                    background: {bg};
                    color: #e5e7eb;
                    font-size: 0.9rem;
                    line-height: 1.4;
                ">
                    <strong>{msg.filename}:{msg.line}</strong><br>
                    {msg.code}: {msg.message}
                </div>
                """,
                    unsafe_allow_html=True,
                )


else:
    st.info("Upload a .py file from the sidebar to begin analysis.")


if uploaded:

    st.subheader("Docstring Generator")

if generate_btn and uploaded:
    st.subheader("Updated File with Docstrings")

    try:
        # STEP 1 ‚Äî Parse original AST BEFORE modifying code
        tree = ast.parse(code)
        attach_parents(tree)
        node_map = map_nodes(tree)

        # STEP 2 ‚Äî Insert module docstring FIRST (text operation, no AST)
        code_with_module = add_module_docstring(code)

        # STEP 3 ‚Äî Re-parse AST AFTER module docstring shift
        tree2 = ast.parse(code_with_module)
        attach_parents(tree2)
        node_map2 = map_nodes(tree2)

        # STEP 4 ‚Äî Now insert function/class docstrings safely
        updated_code = insert_docstrings_into_code(code_with_module, node_map2, format_type, mode_value)

        # Show updated code
        st.code(updated_code, language="python")

        # Download button
        st.download_button(
            label="‚¨áÔ∏èDownload Updated File",
            data=updated_code,
            file_name="updated_docstrings.py",
            mime="text/plain",
        )

    except Exception as e:
        st.error(f"Error generating docstrings: {str(e)}")
